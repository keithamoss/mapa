import { createAsyncThunk, createSelector, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { QueryStatus } from '@reduxjs/toolkit/query';
import { Coordinate } from 'ol/coordinate';
import { authApi } from '../../app/services/auth';
import { featuresApi, MapaFeature } from '../../app/services/features';
import { RootState } from '../../app/store';
import { selectMapsResult } from '../maps/mapsSlice';
import { convertFeaturesToGeoJSON, GeoJSONFeatureCollection } from '../ol_map/olLayerManager';
import { WebGLLayerSpriteSheet } from '../ol_map/olWebGLPointsLayerManager';
import { selectAllFeatureSchemas } from '../schemas/schemasSlice';

export interface OLMapView {
	center: Coordinate;
	zoom: number;
	resolution: number;
}

export enum eMapFeaturesLoadingStatus {
	LOADING,
	SUCCEEDED,
	FAILED,
}

export enum SearchField {
	SymbolName = 'symbol_name',
	SchemaTextFields = 'text_fields',
	SchemaDateFields = 'date_fields',
}

export enum SearchFieldLabel {
	symbol_name = 'Symbol name',
	text_fields = 'Text fields',
	date_fields = 'Date fields',
}

export interface SearchParameters {
	search_term: string;
	search_fields: SearchField[];
}

export interface SearchLocationsParameters {
	search_term: string;
}

export interface AppState {
	mapId: number | undefined;
	mapView: Partial<OLMapView> | undefined;
	mapFeatures: {
		status: eMapFeaturesLoadingStatus | undefined;
		features: GeoJSONFeatureCollection;
		spriteSheet: WebGLLayerSpriteSheet | undefined;
	};
	featuresAvailableForEditing: MapaFeature[];
	search: {
		parameters: SearchParameters;
		filteredFeatures: number[];
	};
	searchLocations: {
		parameters: SearchLocationsParameters;
		zoomToCoordinates?: [number, number];
	};
}

export const defaultSearchParameters = {
	search_term: '',
	search_fields: [SearchField.SymbolName, SearchField.SchemaTextFields],
};

export const defaultSearchLocationsParameters = {
	search_term: '',
};

const initialState: AppState = {
	mapId: undefined,
	mapView: undefined,
	mapFeatures: {
		status: undefined,
		features: {
			type: 'FeatureCollection',
			features: [],
		},
		spriteSheet: undefined,
	},
	featuresAvailableForEditing: [],
	search: {
		parameters: defaultSearchParameters,
		filteredFeatures: [],
	},
	searchLocations: {
		parameters: defaultSearchLocationsParameters,
		zoomToCoordinates: undefined,
	},
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   "counter/fetchCount",
//   async (amount: number) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const appSlice = createSlice({
	name: 'app',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		// increment: (state) => {
		//   // Redux Toolkit allows us to write "mutating" logic in reducers. It
		//   // doesn't actually mutate the state because it uses the Immer library,
		//   // which detects changes to a "draft state" and produces a brand new
		//   // immutable state based off those changes
		//   state.value += 1;
		// },
		// decrement: (state) => {
		//   state.value -= 1;
		// },
		// Use the PayloadAction type to declare the contents of `action.payload`
		setActiveMapId: (state, action: PayloadAction<number>) => {
			state.mapId = action.payload;
		},
		setMapView: (state, action: PayloadAction<Partial<OLMapView>>) => {
			state.mapView = action.payload;
		},
		setMapFeaturesStatus: (state, action: PayloadAction<eMapFeaturesLoadingStatus>) => {
			state.mapFeatures.status = action.payload;
		},
		setFeaturesAvailableForEditing: (state, action: PayloadAction<MapaFeature[]>) => {
			state.featuresAvailableForEditing = action.payload;
		},
		setSearchParameters: (state, action: PayloadAction<SearchParameters>) => {
			state.search.parameters = action.payload;
		},
		setFilteredFeatures: (state, action: PayloadAction<number[]>) => {
			state.search.filteredFeatures = action.payload;
		},
		setSearchLocationsParameters: (state, action: PayloadAction<SearchLocationsParameters>) => {
			state.searchLocations.parameters = action.payload;
		},
		setSearchLocationsZoomToCoordinates: (state, action: PayloadAction<[number, number] | undefined>) => {
			state.searchLocations.zoomToCoordinates = action.payload;
		},
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(prepareFeaturesForMap.pending, (state) => {
				state.mapFeatures.status = eMapFeaturesLoadingStatus.LOADING;
			})
			.addCase(prepareFeaturesForMap.fulfilled, (state, action) => {
				state.mapFeatures.status = eMapFeaturesLoadingStatus.SUCCEEDED;
				if (action.payload !== undefined) {
					state.mapFeatures.features = action.payload.geoJSON;
					state.mapFeatures.spriteSheet = action.payload.spriteSheet;
				}
			})
			.addCase(prepareFeaturesForMap.rejected, (state) => {
				state.mapFeatures.status = eMapFeaturesLoadingStatus.FAILED;
			})
			.addMatcher(authApi.endpoints.checkLoginStatus.matchFulfilled, (state, action) => {
				if (action.payload.user?.settings.last_map_id !== undefined) {
					state.mapId = action.payload.user?.settings.last_map_id;
				}
			})
			.addMatcher(authApi.endpoints.updateUserProfile.matchFulfilled, (state, action) => {
				if (action.payload.last_map_id !== undefined) {
					state.mapId = action.payload.last_map_id;
				}
			});
	},
});

export const {
	setActiveMapId,
	setMapView,
	setMapFeaturesStatus,
	setFeaturesAvailableForEditing,
	setSearchParameters,
	setFilteredFeatures,
	setSearchLocationsParameters,
	setSearchLocationsZoomToCoordinates,
} = appSlice.actions;

export const prepareFeaturesForMap = createAsyncThunk('app/prepareFeaturesForMap', async (arg, { getState }) => {
	// console.log('# prepareFeaturesForMap');
	const state = getState() as RootState;

	const activeMapId = selectActiveMapId(state);
	const maps = selectMapsResult(state);

	if (activeMapId !== undefined && maps.data !== undefined) {
		// console.log('# prepareFeaturesForMap: Active map set and maps.data loaded');
		const activeMap = maps.data.entities[activeMapId];
		const featuresResult = featuresApi.endpoints.getFeatures.select()(state);

		if (activeMap !== undefined && featuresResult.data !== undefined) {
			// console.log('# prepareFeaturesForMap: Active map retrieved and featuresResult.data loaded');

			const features = Object.values(featuresResult.data.entities) || [];
			// console.log('# prepareFeaturesForMap features.length', features.length);

			const geoJSONFeatures = await convertFeaturesToGeoJSON(
				features,
				activeMap.default_symbology,
				selectAllFeatureSchemas(state),
			);

			return geoJSONFeatures;
		}
	}
});

// Once OL adds a way to specify styles using a flat style object, we can just use a selector
// rather than an async thunk. (They're working on it.)
// export const selectFeatureGeoJSON = createSelector(
// 	selectFeaturessResult,
// 	getFilteredFeatureIds,
// 	selectActiveMapId,
// 	selectMapsResult,
// 	selectAllFeatureSchemas,
// 	selectUser,
// 	(features, filteredFeatureIds, activeMapId, maps, schemas, user) => {
// 		console.log('selectFeatureGeoJSON.features', features);
// 		console.log('selectFeatureGeoJSON.filteredFeatureIds', filteredFeatureIds);
// 		console.log('selectFeatureGeoJSON.activeMapId', activeMapId);
// 		console.log('selectFeatureGeoJSON.maps', maps);
// 		console.log('selectFeatureGeoJSON.schemas', schemas);
// 		console.log('selectFeatureGeoJSON.user', user);

// 		if (
// 			features.data !== undefined &&
// 			activeMapId !== undefined &&
// 			maps.data !== undefined
// 			// schemas.data !== undefined &&
// 			// schemas.data.entities !== undefined
// 		) {
// 			return convertFeaturesToGeoJSONSync(
// 				Object.values(features.data),
// 				maps.data.entities[activeMapId]?.default_symbology || null,
// 				schemas,
// 				// Object.values(schemas.data.entities) as any,
// 			);
// 		}

// 		return ['foobar'];
// 	},
// );

export const selectActiveMapId = (state: RootState) => state.app.mapId;

export const selectMapView = (state: RootState) => state.app.mapView;
export const isMapLoadingViaRTKOrManuallySpecified = (state: RootState) => {
	try {
		return (
			state.api.queries['getFeatures(undefined)']?.status === QueryStatus.pending ||
			state.app.mapFeatures.status === eMapFeaturesLoadingStatus.LOADING
		);
	} catch {
		/* empty */
	}

	return true;
};
export const isMapLoadingSucceededViaRTKOrManuallySpecified = (state: RootState) => {
	try {
		return (
			state.api.queries['getFeatures(undefined)']?.status === QueryStatus.fulfilled ||
			state.app.mapFeatures.status === eMapFeaturesLoadingStatus.SUCCEEDED
		);
	} catch {
		/* empty */
	}

	return true;
};

// export const getMapFeatureLoadingStatus = (state: RootState) => state.app.mapFeatures.status;
// export const getMapFeatureLoadingStatusDirectlyFromRTK = (state: RootState) =>
// 	state.api.queries['getFeatures(undefined)']?.status;

export const getGeoJSONFeaturesLoadingStatus = (state: RootState) => state.app.mapFeatures.status;

export const getGeoJSONFeatures = (state: RootState) => state.app.mapFeatures.features;

export const getGeoJSONFeaturesSpriteSheet = (state: RootState) => state.app.mapFeatures.spriteSheet;

export const getFeaturesAvailableForEditing = (state: RootState) => state.app.featuresAvailableForEditing;

export const getSearchParameters = (state: RootState) => state.app.search.parameters;

export const getFilteredFeatureIds = (state: RootState) => state.app.search.filteredFeatures;

export const getCountOfFilteredFeatureIds = (state: RootState) => state.app.search.filteredFeatures.length;

export const getSearchLocationsParameters = (state: RootState) => state.app.searchLocations.parameters;

export const getSearchLocationsZoomToCoordinates = (state: RootState) => state.app.searchLocations.zoomToCoordinates;

export const selectActiveMap = createSelector(selectActiveMapId, selectMapsResult, (mapId, maps) =>
	mapId !== undefined ? maps.data?.entities[mapId] : undefined,
);

export const selectGeoJSONFeaturesAndSpriteSheet = createSelector(
	getGeoJSONFeatures,
	getFilteredFeatureIds,
	getGeoJSONFeaturesSpriteSheet,
	getGeoJSONFeaturesLoadingStatus,
	(mapFeatures, filteredFeatureIds, mapSpriteSheet, mapFeaturesStatus) => ({
		status: mapFeaturesStatus,
		geoJSON: {
			type: 'FeatureCollection',
			features:
				filteredFeatureIds.length === 0
					? mapFeatures.features
					: mapFeatures.features.filter((f) => filteredFeatureIds.includes(f.id)),
		} as GeoJSONFeatureCollection,
		spriteSheet: mapSpriteSheet,
	}),
);

export default appSlice.reducer;
